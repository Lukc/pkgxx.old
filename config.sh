#!/bin/sh
# Not really tested on a true sh-compliant shell, but it should work
# on any modern shell.

# TODO:
#  * Always try to use the implementations that give the most features.
#  * Do not force to use any particular implementation... so use env vars to
#    let /configure (and so the user) choose.
#  * Get infos about grep and find (uncomplete).

TMP=$(mktemp /tmp/config.sh.XXXXXXXX)

touch $TMP

which () {
# I need a proper and silent implementation of which.
	for i in $(echo "$PATH" | sed "s/:/ /g"); do
		if [ -e "$i/$1" ] && [ -x "$i/$1" ]; then
			echo -n "$i/$1"
			return 0
		fi
	done
	return 1
}

gnu () {
# Just to know what is to gnu, and what is not bloated...
	${1:-echo} --version 2>&1 | grep -q GNU
}

sed=$(which gsed) || sed=$(which sed)
if gnu sed; then
	sed_gnu=true
elif sed -ix -e 's/x/x/' "$TMP" && [ -e "${TMP}x" ]; then
	sed_isuffix=true
	# Background process because we don't care about it, and we want to earn time.
	rm "${TMP}x" &
fi

find=$(which gfind) || find=$(which find)
if gnu find; then
	find_gnu=true
fi

cat << EOF
# Automaticaly generated by $(basename $0).
# Do not edit by hand if possible, use config.sh, which can be found 
# in pkg++'s sources directory.

sed=${sed:-sed}
sed_gnu=${sed_gnu:-false}
sed_isuffix=${sed_isuffix:-false}

find=${find:-find}
find_gnu=${find_gnu:-false}

# EOF
EOF

