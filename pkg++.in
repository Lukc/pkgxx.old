
// vim: syntax=sh

E_GENERAL=1
E_PKGFILE=2
E_DIR_PERM=3
E_DOWNLOAD=4
E_UNPACK=5
E_CONTROL_SUM=6
E_FOOTPRINT=7
E_BUILD=8
E_INSTALL=9
E_INVALID_DOWNLOAD_TOOL=10

info() {
	echo -e "\033[32m=======> $1\033[00m"
}

warning() {
	echo -e "\033[33m=======> WARNING: $1\033[00m" >&2
}

error() {
	echo -e "\033[31m=======> ERROR: $1\033[00m" >&2
}

has() {
	item="$1"
	shift 1
	for t_item in $@; do
		if [[ "$item" = "$t_item" ]]; then
			return 0
		fi
	done
	return 1
}

get_protocol() {
	local PROTOCOL="`echo $1 | cut -d ':' -f 1`"
	echo $PROTOCOL
}
get_filename() {
	if [[ $1 =~ ^(http|https|ftp|file):\/\/.*/(.+) ]] || [[ $1 =~ (svn|git|hg|bzr):.*:\/\/.* ]]; then
		NORMAL_RETURN="$PKGMK_SOURCE_DIR/${BASH_REMATCH[2]}"
		if [[ `get_protocol $1` =~ (svn|git|hg|bzr) ]]; then
			echo "$PKGMK_SOURCE_DIR/$name"
		else
			echo "$NORMAL_RETURN"
		fi
	else
		echo $1
	fi
}

get_basename() {
	local FILE="`echo $1 | sed 's|^.*://.*/||g'`"
	echo $FILE
}

get_pkgfile() {
	local PKGFILE=
	if [[ -n "$PKGMK_PKGFILE" ]]; then
		echo "$PKGMK_PKGFILE"
	elif [[ -n `ls $PKGMK_PKGFILE_NAME-* 2>/dev/null` ]]; then
		for file in $PKGMK_PKGFILE_NAME-*; do
			if [[ "$file" =~ $PKGMK_PKGFILE_NAME-[0-9] ]]; then
				PKGFILE=$file
			fi
		done
		echo "$PKGFILE"
	else
		echo "$PKGMK_PKGFILE_NAME"
	fi
}

get_metafile() {
	local VERSION="`basename "$PKGMK_PKGFILE" | sed -e "s|$PKGMK_PKGFILE_NAME-||"`"
	local DIR="`dirname "$PKGMK_PKGFILE"`"
	if [[ "$VERSION" = `basename $PKGMK_PKGFILE` ]]; then
		echo "$DIR/.$1"
	else
		echo "$DIR/.$1-$VERSION"
	fi
}

check_arch(){
	if [[ "${archs[@]}" ]]; then
		for ARCH in ${archs[@]}; do
			case $ARCH in
			no-arch)
				return 0;;
			$PKGMK_ARCH)
				return 0;;
			esac
		done
		return 1
	else
		return 0
	fi
}

check_kernel(){
	if [[ "${kernels[@]}" ]]; then
		for KERNEL in ${kernels[@]}; do
			case $KERNEL in
			no-kernel)
				return 0;;
			$PKGMK_KERNEL)
				return 0;;
			esac
		done
		return 1
	else
		return 0
	fi
}

check_pkgfile() {
	if [[ ! "$name" ]]; then
		error "Variable 'name' not specified in $PKGMK_PKGFILE."
		exit $E_PKGFILE
	elif [[ ! "$version" ]]; then
		error "Variable 'version' not specified in $PKGMK_PKGFILE."
		exit $E_PKGFILE
	elif [[ ! "$release" ]]; then
		error "Variable 'release' not specified in $PKGMK_PKGFILE."
		exit $E_PKGFILE
	elif [[ "`type -t build`" != "function" ]]; then
		error "Function 'build' not specified in $PKGMK_PKGFILE."
		exit $E_PKGFILE
	elif ! check_arch; then
		error "This package is not made to work on your harware."
		exit 1
	elif ! check_kernel; then
		error "This package is not made to work on your kernel."
		exit 1
	fi
	if [[ "$PKGMK_CHECK" = "yes" ]]; then
		if [[ ! "`type -t check`" = "function" ]]; then
			warning "Function 'check' not specified in $PKGMK_PKGFILE."
			PKGMK_CHECK="no"
		fi
	fi
}

check_directory() {
	if [[ ! -d $1 ]]; then
		error "Directory '$1' does not exist."
		exit $E_DIR_PERM
	elif [[ ! -w $1 ]]; then
		error "Directory '$1' not writable."
		exit $E_DIR_PERM
	elif [[ ! -x $1 ]] || [[ ! -r $1 ]]; then
		error "Directory '$1' not readable."
		exit $E_DIR_PERM
	fi
}

check_file() {
	if [[ -e $1 ]] && [[ ! -w $1 ]]; then
		error "File '$1' is not writable."
		exit 1
	fi
}

check_command() {
	if [[ -z "`type -p $1`" ]]; then
		error "Command '$1' not found."
		exit $E_GENERAL
	fi
}

check_config() {
	if ! has $DOWNLOAD_TOOL ${PKGMK_DOWNLOAD_TOOLS[@]}; then
		error "$DOWNLOAD_TOOL is not a valid download tool. Please, edit your config file."
		echo "Valid values are: ${PKGMK_DOWNLOAD_TOOLS[@]}."
		exit $E_INVALID_DOWNLOAD_TOOL
	fi
}

list_includes() {
	for include in `ls /usr/share/pkg++/includes/`; do
		if grep -q "source=" /usr/share/pkg++/includes/$include; then
			echo -e "\033[34m$include\033[00m"
		elif grep -q "build()" /usr/share/pkg++/includes/$include; then
			echo -e "\033[32m$include\033[00m"
		else
			echo -e "$include"
		fi
	done
}

download_file() {
	info "Getting '$1'."
	
	PROTOCOL="`get_protocol $1`"
	case $PROTOCOL in
		"http"|"https"|"ftp"|"file")
			if [[ "$DOWNLOAD_TOOL" = "curl" ]]; then
				check_command "curl"
			elif [[ "$DOWNLOAD_TOOL" = "wget" ]]; then
				check_command "wget"
			fi
			
			LOCAL_FILENAME=`get_filename $1`
			LOCAL_FILENAME_PARTIAL="$LOCAL_FILENAME.partial"
			
			if [[ "$DOWNLOAD_TOOL" = "curl" ]]; then
				DOWNLOAD_OPTS="-f -L"
			elif [[ "$DOWNLOAD_TOOL" = "wget" ]]; then
				DOWNLOAD_OPTS="--passive-ftp --no-directories --tries=3 --waitretry=3 \
					--directory-prefix=$PKGMK_SOURCE_DIR \
					--output-document=$LOCAL_FILENAME_PARTIAL --no-check-certificate"
			fi
			
			if [[ -f "$LOCAL_FILENAME_PARTIAL" ]]; then
				info "Partial download found, trying to resume"
				if [[ "$DOWNLOAD_TOOL" = "curl" ]]; then
					RESUME_CMD="-C $LOCAL_FILENAME_PARTIAL"
				elif [[ "$DOWNLOAD_TOOL" = "wget" ]]; then
					RESUME_CMD="-c"
				fi
			fi
			
			error=1
			
			BASENAME=`get_basename $1`
			for REPO in ${PKGMK_SOURCE_MIRRORS[@]}; do
				REPO="`echo $REPO | sed 's|/$||'`"
				if [[ "$DOWNLOAD_TOOL" = "curl" ]]; then
					curl $RESUME_CMD $DOWNLOAD_OPTS $PKGMK_CURL_OPTS $REPO/$BASENAME > $LOCAL_FILENAME_PARTIAL
				elif [[ "$DOWNLOAD_TOOL" = "wget" ]]; then
					wget $RESUME_CMD $DOWNLOAD_OPTS $PKGMK_WGET_OPTS $REPO/$BASENAME
				fi
				error=$?
				if [[ $error == 0 ]]; then
					break
				fi
			done
			
			if [[ $error != 0 ]]; then
				while true; do
					if [[ "$DOWNLOAD_TOOL" = "curl" ]]; then
						curl $RESUME_CMD $DOWNLOAD_OPTS $PKGMK_CURL_OPTS $1 > $LOCAL_FILENAME_PARTIAL
					elif [[ "$DOWNLOAD_TOOL" = "wget" ]]; then
						wget $RESUME_CMD $DOWNLOAD_OPTS $PKGMK_WGET_OPTS $1
					fi
					error=$?
						if [[ $error != 0 ]] && [[ "$RESUME_CMD" ]]; then
						info "Partial download failed, restarting"
						rm -f "$LOCAL_FILENAME_PARTIAL"
						RESUME_CMD=""
					else
							break
					fi
				done
			fi
				
			if [[ $error != 0 ]]; then
				error "Downloading '$1' failed."
				exit $E_DOWNLOAD
			fi
				
			mv -f "$LOCAL_FILENAME_PARTIAL" "$LOCAL_FILENAME"
		;;
		"svn")
			check_command "svn"
			cd $PKGMK_SOURCE_DIR
			if cd $name 2&> /dev/null; then
				if [[ "`LANG=en_US.utf8 svn up`" =~ 'At revision '*'.' ]]; then
					info "Already up-to-date."
					exit 0
				fi
			else
				svn co `echo $1 | sed -e "s|svn:||"` $name
			fi
		;;
		"git"|"hg")
			cd $PKGMK_SOURCE_DIR
			if cd $name 2&> /dev/null; then
				if [[ "$PROTOCOL" = "git" ]]; then
					check_command "git"
					if [[ "`git pull`" = "Already up-to-date." ]] && [[ "$PKGMK_FORCE" != "yes" ]]; then
						info "Already up-to-date."
						exit 0
					fi
				else
					check_command "hg"
					if [[ "`hg pull | tail -n 1`" = "no changes found" ]] && [[ "$PKGMK_FORCE" != "yes" ]]; then
						info "Already up-to-date."
						exit 0
					else
						hg update > /dev/null
					fi
				fi
			else
				$PROTOCOL clone `echo $1 | sed -e "s|$PROTOCOL:||"` $name
			fi
		;;
		"bzr")
			check_command "bzr"
			cd $PKGMK_SOURCE_DIR
			if cd $name 2&> /dev/null; then
				if [[ "`bzr update 2>&1`" =~ "Tree is up to date at revision ".*" of branch ".* ]] && [[ "$PKGMK_FORCE" != "yes" ]]; then
					info "Already up-to-date."
					exit 0
				fi
			else
				bzr branch `echo $1 | sed -e "s|$PROTOCOL:||"` $name
			fi
		;;
	esac
}

download_source() {
	local FILE LOCAL_FILENAME
	
	for FILE in ${source[@]}; do
		LOCAL_FILENAME=`get_filename $FILE`
		if [[ ! -e $LOCAL_FILENAME ]] || [[ "$version" = "devel" ]]; then
			if [[ "$LOCAL_FILENAME" = "$FILE" ]]; then
				error "Source file '$LOCAL_FILENAME' not found (can not be downloaded, URL not specified)."
				exit $E_DOWNLOAD
			else
				if [[ "$PKGMK_DOWNLOAD" = "yes" ]] || [[ "$version" = "devel" ]]; then
					download_file $FILE
				else
					error "Source file '$LOCAL_FILENAME' not found (use option -d to download)."
					exit $E_DOWNLOAD
				fi
			fi
		fi
	done
}

unpack_source() {
	local FILE LOCAL_FILENAME COMMAND
	
	for FILE in ${source[@]}; do
		LOCAL_FILENAME=`get_filename $FILE`
		if [[ "$KEEP_ARCHIVES" != "true" ]]; then
			case $LOCAL_FILENAME in
				#if defined gtar
				*.tar.gz|*.tar.Z|*.tgz)
					COMMAND="tar -C $SRC --use-compress-program=gzip -xf $LOCAL_FILENAME" ;;
				*.tar.bz2|*.tbz2)
					COMMAND="tar -C $SRC --use-compress-program=bzip2 -xf $LOCAL_FILENAME" ;;
				*.tar.xz|*.txz|*.tar.lzma)
					COMMAND="tar -C $SRC --use-compress-program=xz -xf $LOCAL_FILENAME";;
				*.tar)
					COMMAND="tar -C $SRC -xf $LOCAL_FILENAME";;
				*.zip)
					COMMAND="unzip -qq -o -d $SRC $LOCAL_FILENAME" ;;
				#else
				*.tar.gz|*.tar.Z|*.tgz|*.tar.bz2|*.tbz2|*.tar.xz|*.txz|*.tar.lzma|*.zip|*.rpm)
					COMMAND="bsdtar -p -o -C $SRC -xf $LOCAL_FILENAME" ;;
				#endif
				*)
					COMMAND="cp -r $LOCAL_FILENAME $SRC" ;;
			esac
	
			echo "$COMMAND"
	
			$COMMAND
		else
			info "KEEP_ARCHIVES set to true in the Pkgfile: no archive extraction."
		fi
		
		if [[ $? != 0 ]]; then
			if [[ "$PKGMK_KEEP_WORK" = "no" ]]; then
				rm -rf $PKGMK_WORK_DIR
			fi
			error "Building '$TARGET' failed."
			exit $E_UNPACK
		fi
	done
}

make_md5sum() {
	local FILE LOCAL_FILENAMES
	
	if [[ "$source" ]]; then
		for FILE in ${source[@]}; do
			if [[ ! -d "`get_filename $FILE`" ]]; then
				LOCAL_FILENAMES="$LOCAL_FILENAMES `get_filename $FILE`"
			fi
		done
		
		[[ -n "$LOCAL_FILENAMES" ]] && md5sum $LOCAL_FILENAMES | sed -e 's|  .*/|  |' | sort -k 2
	fi
}

make_sha256sum() {
	local FILE LOCAL_FILENAMES

	if [[ "$source" ]]; then
		for FILE in ${source[@]}; do
			if [[ ! -d "`get_filename $FILE`" ]]; then
				LOCAL_FILENAMES="$LOCAL_FILENAMES `get_filename $FILE`"
			fi
		done
		
		[[ -n "$LOCAL_FILENAMES" ]] && sha256sum $LOCAL_FILENAMES | sed -e 's|  .*/|  |' | sort -k 2
	fi
}

make_footprint() {
	pkginfo --footprint $TARGET | \
		sed "s|\tlib/modules/`uname -r`/|\tlib/modules/<kernel-version>/|g" | \
		sort -k 3
}

check_md5sum() {
	local FILE="$PKGMK_WORK_DIR/.tmp"

	cd $PKGMK_ROOT
	
	if [[ -f $PKGMK_MD5SUM ]]; then
		make_md5sum > $FILE.md5sum
		sort -k 2 $PKGMK_MD5SUM > $FILE.md5sum.orig
		diff -w -t -U 0 $FILE.md5sum.orig $FILE.md5sum | \
			sed '/^@@/d' | \
			sed '/^+++/d' | \
			sed '/^---/d' | \
			sed 's/^+/NEW       /g' | \
			sed 's/^-/MISSING   /g' > $FILE.md5sum.diff
		if [[ -s $FILE.md5sum.diff ]]; then
			error "Md5sum mismatch found:"
			cat $FILE.md5sum.diff >&2

			if [[ "$PKGMK_KEEP_WORK" = "no" ]]; then
				rm -rf $PKGMK_WORK_DIR
			fi

			if [[ "$PKGMK_CHECK_MD5SUM" = "yes" ]]; then
				error "Md5sum not ok."
				exit $E_CONTROL_SUM
			fi

			error "Building '$TARGET' failed."
			exit $E_CONTROL_SUM
		fi
	else
		if [[ "$PKGMK_CHECK_MD5SUM" = "yes" ]]; then
			if [[ "$PKGMK_KEEP_WORK" = "no" ]]; then
				rm -rf $PKGMK_WORK_DIR
			fi
			info "Md5sum not found."
			exit $E_CONTROL_SUM
		fi
		
		warning "Md5sum not found, creating new."
		make_md5sum > $PKGMK_MD5SUM
	fi

	if [[ "$PKGMK_CHECK_MD5SUM" = "yes" ]]; then
		if [[ "$PKGMK_KEEP_WORK" = "no" ]]; then
			rm -rf $PKGMK_WORK_DIR
		fi
		info "Md5sum ok."
		exit 0
	fi
}

check_sha256sum() {
	local FILE="$PKGMK_WORK_DIR/.tmp"

	cd $PKGMK_ROOT
	
	if [[ -f $PKGMK_SHA256SUM ]]; then
		make_sha256sum > $FILE.sha256sum
		sort -k 2 $PKGMK_SHA256SUM > $FILE.sha256sum.orig
		diff -w -t -U 0 $FILE.sha256sum.orig $FILE.sha256sum | \
			sed '/^@@/d' | \
			sed '/^+++/d' | \
			sed '/^---/d' | \
			sed 's/^+/NEW       /g' | \
			sed 's/^-/MISSING   /g' > $FILE.sha256sum.diff
		if [[ -s $FILE.sha256sum.diff ]]; then
			error "Sha256sum mismatch found:"
			cat $FILE.sha256sum.diff >&2

			if [[ "$PKGMK_KEEP_WORK" = "no" ]]; then
				rm -rf $PKGMK_WORK_DIR
			fi

			if [[ "$PKGMK_CHECK_SHA256SUM" = "yes" ]]; then
				error "Sha256sum not ok."
				exit $E_CONTROL_SUM
			fi

			error "Building '$TARGET' failed."
			exit $E_CONTROL_SUM
		fi
	else
		if [[ "$PKGMK_CHECK_SHA256SUM" = "yes" ]]; then
			if [[ "$PKGMK_KEEP_WORK" = "no" ]]; then
				rm -rf $PKGMK_WORK_DIR
			fi
			info "Sha256sum not found."
			exit $E_CONTROL_SUM
		fi
		
		warning "Sha256sum not found, creating new."
		make_sha256sum > $PKGMK_SHA256SUM
	fi

	if [[ "$PKGMK_CHECK_MD5SUM" = "yes" ]]; then
		if [[ "$PKGMK_KEEP_WORK" = "no" ]]; then
			rm -rf $PKGMK_WORK_DIR
		fi
		info "Md5sum ok."
		exit 0
	fi
}

strip_files() {
	local FILE FILTER
	
	cd $PKG
	
	if [[ -f $PKGMK_ROOT/$PKGMK_NOSTRIP ]]; then
		FILTER="grep -v -f $PKGMK_ROOT/$PKGMK_NOSTRIP"
	else
		FILTER="cat"
	fi
	
	/*
	 * This corrects a problem on non-GNU userlands…
	 */
	#if defined gfind
	find . -type f -printf "%P\n" \\
	/*
	 * This one uses the GNU find, and it’s -printf option.
	 */
	#else
	find . -type f | sed "s|\./||" \\
	/*
	 * And this one uses sed to truncate the begin of the relative file’s path.
	 */
	#endif
		| $FILTER | while read FILE; do
		case $(file -b "$FILE") in
		*ELF*executable*not\ stripped)
			strip --strip-all "$FILE"
			;;
		*ELF*shared\ object*not\ stripped)
			strip --strip-unneeded "$FILE"
			;;
		current\ ar\ archive)
			strip --strip-debug "$FILE"
		esac
	done
}

compress_manpages() {
	local FILE DIR TARGET

	cd $PKG
	
	find . -type f -path "*/man/man*/*" | while read FILE; do
		if [[ "$FILE" = "${FILE%%.gz}" ]]; then
			gzip -9 "$FILE"
		fi
	done
	
	find . -type l -path "*/man/man*/*" | while read FILE; do
		TARGET=`readlink -n "$FILE"`
		TARGET="${TARGET##*/}"
		TARGET="${TARGET%%.gz}.gz"
		rm -f "$FILE"
		FILE="${FILE%%.gz}.gz"
		DIR=`dirname "$FILE"`

		if [[ -e "$DIR/$TARGET" ]]; then
			ln -sf "$TARGET" "$FILE"
		fi
	done
}

check_footprint() {
	local FILE="$PKGMK_WORK_DIR/.tmp"
	
	cd $PKGMK_ROOT
	
	if [[ -f $TARGET ]]; then
		make_footprint > $FILE.footprint
		if [[ -f $PKGMK_FOOTPRINT ]]; then
			sort -k 3 $PKGMK_FOOTPRINT > $FILE.footprint.orig
			diff -w -t -U 0 $FILE.footprint.orig $FILE.footprint | \
				sed '/^@@/d' | \
				sed '/^+++/d' | \
				sed '/^---/d' | \
				sed 's/^+/NEW       /g' | \
				sed 's/^-/MISSING   /g' > $FILE.footprint.diff
			if [[ -s $FILE.footprint.diff ]] && [[ "$version" != "devel" ]]; then
				if [[ "$PKGMK_IGNORE_NEW" = "yes" ]] && \
				   [[ -z "$(egrep -l ^MISSING $FILE.footprint.diff)" ]]; then
					info "New files found:"
				else
					error "Footprint mismatch found:"
					BUILD_SUCCESSFUL="no"
				fi
				cat $FILE.footprint.diff >&2
			fi
		else
			warning "Footprint not found, creating new."
			mv $FILE.footprint $PKGMK_FOOTPRINT
		fi
	else
		error "Package '$TARGET' was not found."
		BUILD_SUCCESSFUL="no"
	fi
}

make_work_dir() {
	export PKG="$PKGMK_WORK_DIR/pkg"
	export SRC="$PKGMK_WORK_DIR/src"
	umask 022
	
	cd $PKGMK_ROOT
	remove_work_dir
	mkdir -p $SRC $PKG
	
	if [[ "$PKGMK_IGNORE_MD5SUM" = "no" ]]; then
		if [[ -n "`type -p md5sum`" ]]; then
			check_md5sum
		else
			warning "'md5sum' command not found. md5sum verification ignored."
		fi
	fi
	
	if [[ "$PKGMK_IGNORE_SHA256SUM" = "no" ]]; then
		if [[ -n "`type -p sha256sum`" ]]; then
			check_sha256sum
		else
			warning "'sha256sum' command not found. sha256sum verification ignored."
		fi
	fi
}

remove_work_dir() {
	rm -rf $PKGMK_WORK_DIR
}


build_package() {
	local BUILD_SUCCESSFUL="no"
	
	check_file "$TARGET"
	make_work_dir

	if [[ "$UID" != "0" ]]; then
		warning "Packages should be built as root."
	fi
	
	info "Building '$TARGET'."
	
	unpack_source
	
	cd $SRC
	if [[ "`type -t pre_build`" = "function" ]]; then
		(set -e -x ; pre_build)
	fi
	(set -e -x ; build)
	if [[ "`type -t post_build`" = "function" ]]; then
		(set -e -x ; post_build)
	fi
	
	if [[ "$PKGMK_CHECK" = "yes" ]]; then
		info "Testing $TARGET."
		if check; then
			info "$TARGET successfully tested."
		else
			error "Tests of $TARGET failed."
			exit 1
		fi
	fi
	
	if [[ $? = 0 ]]; then
		if [[ "$PKGMK_NO_STRIP" = "no" ]]; then
			strip_files
		fi
		
		compress_manpages
		
		cd $PKG
		info "Build result:"
		#if defined debian
		// I don’t know how to have a correct footprint with .deb packages…
		info "Debian package construction."
		mkdir DEBIAN
		[[ -e DEBIAN/control ]] && rm DEBIAN/control
		echo "Package: $name" >> DEBIAN/control
		echo "Version: $version" >> DEBIAN/control
		if [[ "$arch" = "no-arch" ]] && [[ "$kernel" = "no-kernel" ]]; then
			echo "Architecture: all" >> DEBIAN/control
		else
			echo "Architecture: $PKGMK_ARCH" >> DEBIAN/control
		fi
		echo "Maintainer: $maintainer" >> DEBIAN/control
		echo "Description: $description" >> DEBIAN/control
		echo -n "Depends: " >> DEBIAN/control
		for n in ${!depends[*]}; do
			if [[ -n "${depends[$(($n+1))]}" ]]; then
				echo -n "${depends[$n]},">> DEBIAN/control
			else
				echo -n "${depends[$n]}">> DEBIAN/control
			fi
		done
		echo >> DEBIAN/control
		echo "Homepage: $url" >> DEBIAN/control
		echo >> DEBIAN/control
		cd ..
		dpkg-deb --build $PKG
		mv pkg.deb $TARGET
		dpkg -c $TARGET /* dpkg can show the content of a package. It’s
				 * not a Crux valid footprint, so it is only
				 * displayed after a successful build, and not
				 * used for footprints. Using it for footprints
				 * is in TODO. */
		#else
		tar cvvf ${TARGET%.$EXT} *
		
		case $PKGMK_COMPRESSION_MODE in
			gz)
				gzip -f ${TARGET%.$EXT}
			;;
			bz2)
				bzip2 -f ${TARGET%.$EXT}
			;;
			xz)
				xz -f ${TARGET%.$EXT}
			;;
			lzo)
				lzop -Uf ${TARGET%.$EXT}
			;;
		esac
		#endif
		
		if [[ $? = 0 ]]; then
			BUILD_SUCCESSFUL="yes"

			if [[ "$PKGMK_IGNORE_FOOTPRINT" = "yes" ]]; then
				warning "Footprint ignored."
			else
				check_footprint
			fi
		fi
	fi
	
	if [[ "$PKGMK_KEEP_WORK" = "no" ]]; then
		remove_work_dir
	fi
	
	if [[ "$BUILD_SUCCESSFUL" = "yes" ]]; then
		info "Building '$TARGET' succeeded."
	else
		if [[ -f $TARGET ]]; then
			touch -r $PKGMK_ROOT/$PKGMK_PKGFILE $TARGET &> /dev/null
		fi
		error "Building '$TARGET' failed."
		exit 1
	fi
}

install_package() {
	local COMMAND
	
	info "Installing '$TARGET'."
	
	#if defined debian
	COMMAND="dpkg -i $TARGET"
	#else
	if [[ "$PKGMK_INSTALL" = "install" ]]; then
		COMMAND="pkgadd $TARGET"
	else
		COMMAND="pkgadd -u $TARGET"
	fi
	#endif
	
	cd $PKGMK_ROOT
	echo "$COMMAND"
	$COMMAND
	
	if [[ $? = 0 ]]; then
		info "Installing '$TARGET' succeeded."
	else
		error "Installing '$TARGET' failed."
		exit 1
	fi
}

recursive() {
	local ARGS FILE DIR
	
	ARGS=`echo "$@" | sed -e "s/--recursive//g" -e "s/-r//g"`
	
	for FILE in `find $PKGMK_ROOT -name $PKGMK_PKGFILE | sort`; do
		DIR="`dirname $FILE`/"
		if [[ -d $DIR ]]; then
			info "Entering directory '$DIR'."
			(cd $DIR && $PKGMK_COMMAND $ARGS)
			info "Leaving directory '$DIR'."
		fi
	done
}

clean() {
	local FILE LOCAL_FILENAME
	
	if [[ -f $TARGET ]]; then
		info "Removing $TARGET"
		rm -f $TARGET
	fi
	
	for FILE in ${source[@]}; do
		LOCAL_FILENAME=`get_filename $FILE`
		if [[ -e $LOCAL_FILENAME ]] && [[ "$LOCAL_FILENAME" != "$FILE" ]]; then
			info "Removing $LOCAL_FILENAME"
			rm -f $LOCAL_FILENAME
		fi
	done
}

update_footprint() {
	if [[ ! -f $TARGET ]]; then
		error "Unable to update footprint. File '$TARGET' not found."
		exit 1
	fi
	
	check_file "$PKGMK_FOOTPRINT"
	make_footprint > $PKGMK_FOOTPRINT
	touch $TARGET
	
	info "Footprint updated."
}

build_needed() {
	local FILE RESULT
	
	RESULT="yes"
	if [[ -f $TARGET ]]; then
		RESULT="no"
		for FILE in $PKGMK_PKGFILE ${source[@]}; do
			FILE=`get_filename $FILE`
			if [[ ! -e $FILE ]] || [[ ! $TARGET -nt $FILE ]]; then
				RESULT="yes"
				break
			fi
		done
	fi
	
	echo $RESULT
}

interrupted() {
	echo ""
	error "Interrupted."
	
	if [[ "$PKGMK_KEEP_WORK" = "no" ]]; then
		rm -rf $PKGMK_WORK_DIR
	fi
	
	exit 1
}

print_help() {
	echo "usage: `basename $PKGMK_COMMAND` [$PKGMK_PKGFILE_NAME] [options]"
	echo "options:"
	echo "  -i,   --install             build and install package"
	echo "  -u,   --upgrade             build and install package (as upgrade)"
	echo "  -r,   --recursive           search for and build packages recursively"
	echo "  -d,   --download            download missing source file(s)"
	echo "  -do,  --download-only       do not build, only download missing source file(s)"
	echo "  -eo,  --extract-only        do not build, only extract source file(s)"
	echo "  -utd, --up-to-date          do not build, only check if package is up to date"
	echo "  -uf,  --update-footprint    update footprint using result from last build"
	echo "  -if,  --ignore-footprint    build package without checking footprint"
	echo "  -in,  --ignore-new          build package, ignore new files in a footprint missmatch"
	echo "  -um,  --update-md5sum       update md5sum"
	echo "  -im,  --ignore-md5sum       build package without checking md5sum"
	echo "  -cm,  --check-md5sum        do not build, only check md5sum"
	echo "  -us,  --update-sha256sum    update sha256sum"
	echo "  -is,  --ignore-sha256sum    build package without checking sha256sum"
	echo "  -cs,  --check-sha256sum     do not build, only check sha256sum"
	echo "  -ns,  --no-strip            do not strip executable binaries or libraries"
	echo "  -f,   --force               build package even if it appears to be up to date"
	echo "  -c,   --clean               remove package and downloaded files"
	echo "  -cp   --check-pkgfile       do not build, only check \`$PKGMK_PKGFILE_NAME'"
	echo "  -kw,  --keep-work           keep temporary working directory"
	echo "  -cf,  --config-file <file>  use alternative configuration file"
	echo "  -li,  --list-includes       list all inclusion files available"
	echo "  -v,   --version             print version and exit "
	echo "  -h,   --help                print help and exit"
}

parse_options() {
	local PKGFILE=""
	while [[ "$1" ]]; do
		case $1 in
			-i|--install)
				PKGMK_INSTALL="install" ;;
			-u|--upgrade)
				PKGMK_INSTALL="upgrade" ;;
			-r|--recursive)
				PKGMK_RECURSIVE="yes" ;;
			-d|--download)
				PKGMK_DOWNLOAD="yes" ;;
			-do|--download-only)
				PKGMK_DOWNLOAD="yes"
				PKGMK_DOWNLOAD_ONLY="yes" ;;
			-eo|--extract-only)
				PKGMK_EXTRACT_ONLY="yes" ;;
			-utd|--up-to-date)
				PKGMK_UP_TO_DATE="yes" ;;
			-uf|--update-footprint)
				PKGMK_UPDATE_FOOTPRINT="yes" ;;
			-if|--ignore-footprint)
				PKGMK_IGNORE_FOOTPRINT="yes" ;;
			-in|--ignore-new)
				PKGMK_IGNORE_NEW="yes" ;;
			-um|--update-md5sum)
				PKGMK_UPDATE_MD5SUM="yes" ;;
			-im|--ignore-md5sum)
				PKGMK_IGNORE_MD5SUM="yes" ;;
			-cm|--check-md5sum)
				PKGMK_CHECK_MD5SUM="yes" ;;
			-us|--update-sha256sum)
				PKGMK_UPDATE_SHA256SUM="yes" ;;
			-is|--ignore-sha256sum)
				PKGMK_IGNORE_SHA256SUM="yes" ;;
			-cs|--check-sha256sum)
				PKGMK_CHECK_SHA256SUM="yes" ;;
			-ns|--no-strip)
				PKGMK_NO_STRIP="yes" ;;
			-f|--force)
				PKGMK_FORCE="yes" ;;
			-c|--clean)
				PKGMK_CLEAN="yes" ;;
			-kw|--keep-work)
				PKGMK_KEEP_WORK="yes" ;;
			-cp|--check-pkgfile)
				PKGMK_CHECK_PKGFILE="yes";;
			-cf|--config-file)
				if [[ ! "$2" ]]; then
					echo "`basename $PKGMK_COMMAND`: option $1 requires an argument"
					exit 1
				fi
				PKGMK_CONFFILE="$2"
				shift ;;
			-li|--list-includes)
				PKGMK_LIST_INCLUDES="yes";;
			-v|--version)
				echo "`basename $PKGMK_COMMAND` $PKGMK_VERSION"
				exit 0 ;;
			-h|--help)
				print_help
				exit 0 ;;
			*)
				if [[ -n "$PKGFILE" ]]; then
					echo "`basename $PKGMK_COMMAND`: only one $PKGMK_PKGFILE_NAME can be given"
					exit 1
				elif [[ -r "$1" ]]; then
					PKGFILE="$1"
				else
					echo "`basename $PKGMK_COMMAND`: invalid option $1"
					exit 1
				fi ;;
		esac
		shift
	done
	PKGMK_PKGFILE="$PKGFILE"
}

main() {
	local FILE TARGET
	export EXT=""
	
	parse_options "$@"
	
	pkgmake() {
		make $MAKE_OPTS $@
	}
	
	use() {
		for flag in ${USE[@]}; do
			if [[ "$flag" = "$1" ]] || [[ "$flag" = "+$1" ]]; then
				return 0
			elif [[ "$flag" = "-$1" ]]; then
				return 1
			fi
		done
		return 1
	}
	
	if [[ "$PKGMK_LIST_INCLUDES" = "yes" ]]; then
		list_includes
		exit 0
	fi
		
	if [[ "$PKGMK_RECURSIVE" = "yes" ]]; then
		recursive "$@"
		exit 0
	fi
	
	PKGMK_PKGFILE="`get_pkgfile`"
	
	PKGMK_FOOTPRINT="`get_metafile footprint`"
	PKGMK_MD5SUM="`get_metafile md5sum`"
	PKGMK_SHA256SUM="`get_metafile sha256sum`"
	PKGMK_NOSTRIP="`get_metafile nostrip`"
	
	for FILE in $PKGMK_CONFFILE $PKGMK_PKGFILE $PKGMK_CONFFILE; do
		if [[ ! -f $FILE ]]; then
			error "File '$FILE' not found."
			exit 1
		fi
		. $FILE
	done
	
	#if defined debian
	if [[ "$PKGMK_ARCH" = x86 ]]; then
		PKGMK_ARCH="i386"
	elif [[ "$PKGMK_ARCH" = x86_64 ]]; then
		PKGMK_ARCH="amd64"
	fi
	#endif
	
	check_config
	
	for INCLUDE in ${includes[@]}; do
		. $PKGMK_INCLUDES_DIR/$INCLUDE
	done
	
	if [[ "$PKGMK_CHECK_PKGFILE" = "yes" ]]; then
		RETURN=0
		if [[ ! "$description" ]]; then
			error "Variable 'description' not specified in $PKGMK_PKGFILE."
			RETURN=1
		fi
		if [[ ! "$url" ]]; then
			error "Variable 'url' not specified in $PKGMK_PKGFILE."
			RETURN=1
		fi
		if [[ ! "$packager" ]]; then
			error "Variable 'packager' not specified in $PKGMK_PKGFILE."
			RETURN=1
		fi
		if [[ ! "$maintainer" ]]; then
			error "Variable 'maintainer' not specified in $PKGMK_PKGFILE."
			RETURN=1
		fi
		if [[ ! "$depends" ]]; then
			error "Variable 'depends' not specified in $PKGMK_PKGFILE."
			RETURN=1
		fi
		if [[ ! "$name" ]]; then
			error "Variable 'name' not specified in $PKGMK_PKGFILE."
			RETURN=1
		fi
		if [[ ! "$version" ]]; then
			error "Variable 'version' not specified in $PKGMK_PKGFILE."
			RETURN=1
		fi
		if [[ ! "$release" ]]; then
			error "Variable 'release' not specified in $PKGMK_PKGFILE."
			RETURN=1
		fi
		if [[ "`type -t pre_build`" != "function" ]]; then
			info "Function 'pre_build' not specified in $PKGMK_PKGFILE."
		fi
		if [[ "`type -t build`" != "function" ]]; then
			error "Function 'build' not specified in $PKGMK_PKGFILE."
			RETURN=1
		fi
		if [[ "`type -t post_build`" != "function" ]]; then
			info "Function 'post_build' not specified in $PKGMK_PKGFILE."
		fi
		if [[ "`type -t check`" != "function" ]]; then
			warning "Function 'check' not specified in $PKGMK_PKGFILE."
			RETURN=1
		fi
		exit $RETURN
	fi
	
	check_directory "$PKGMK_SOURCE_DIR"
	check_directory "$PKGMK_PACKAGE_DIR"
	check_directory "`dirname $PKGMK_WORK_DIR`"
	
	check_pkgfile
	
	#if defined debian
	if [[ "$version" = "devel" ]] || [[ "$version" = "dev" ]]; then
		TARGET="$PKGMK_PACKAGE_DIR/$name#devel-`date +%Y%m%d`-$release.deb"
	else
		TARGET="$PKGMK_PACKAGE_DIR/$name#$version-$release.deb"
	fi
	#else
	case $PKGMK_COMPRESSION_MODE in
	gz|bz2|xz|lzo)
		EXT="$PKGMK_COMPRESSION_MODE"
		;;
	none);;
	*)
		error "Compression mode '$PKGMK_COMPRESSION_MODE' not supported"
		exit 1
		;;
	esac
	
	if [[ "$version" = "devel" ]] || [[ "$version" = "dev" ]]; then
		TARGET="$PKGMK_PACKAGE_DIR/$name#devel-`date +%Y%m%d`-$release.pkg.tar"
	else
		TARGET="$PKGMK_PACKAGE_DIR/$name#$version-$release.pkg.tar"
	fi
	
	if [[ -n "$EXT" ]]; then
		TARGET="$TARGET.$EXT"
	fi
	#endif
	
	if [[ "$PKGMK_CLEAN" = "yes" ]]; then
		clean
		exit 0
	fi
	
	if [[ "$PKGMK_UPDATE_FOOTPRINT" = "yes" ]]; then
		update_footprint
		exit 0
	fi
	
	if [[ "$PKGMK_UPDATE_MD5SUM" = "yes" ]]; then
		download_source
		check_file "$PKGMK_MD5SUM"
		make_md5sum > $PKGMK_MD5SUM
		info "Md5sum updated."
	fi
	
	if [[ "$PKGMK_UPDATE_SHA256SUM" = "yes" ]]; then
		download_source
		check_file "$PKGMK_SHA256SUM"
		make_sha256sum > $PKGMK_SHA256SUM
		info "Sha256sum updated."
	fi
	if [[ "$PKGMK_UPDATE_SHA256SUM" = "yes" ]] || [[ "$PKGMK_UPDATE_MD5SUM" = "yes" ]]; then
		exit 0
	fi
	
	if [[ "$PKGMK_DOWNLOAD_ONLY" = "yes" ]]; then
		download_source
		exit 0
	fi
	
	if [[ "$PKGMK_EXTRACT_ONLY" = "yes" ]]; then
		download_source
		make_work_dir
		info "Extracting sources of package '$name-$version'."
		unpack_source
		exit 0
	fi
	
	if [[ "$PKGMK_UP_TO_DATE" = "yes" ]]; then
		if [[ "`build_needed`" = "yes" ]]; then
			info "Package '$TARGET' is not up to date."
		else
			info "Package '$TARGET' is up to date."
		fi
		exit 0
	fi
	
	if [[ "`build_needed`" = "no" ]] && [[ "$PKGMK_FORCE" = "no" ]] && [[ "$PKGMK_CHECK_MD5SUM" = "no" ]] && [[ "$version" != "devel" ]]; then
		info "Package '$TARGET' is up to date."
	else
		download_source
		build_package
	fi
	
	if [[ "$PKGMK_INSTALL" != "no" ]]; then
		install_package
	fi
	
	exit 0
}

trap "interrupted" SIGHUP SIGINT SIGQUIT SIGTERM

export LC_ALL=POSIX

readonly PKGMK_VERSION="@VERSION@"
readonly PKGMK_COMMAND="$0"
readonly PKGMK_ROOT="$PWD"

PKGMK_CONFFILE="/etc/pkg++.conf"
PKGMK_INCLUDES_DIR="/usr/share/pkg++/includes"
PKGMK_PKGFILE_NAME="Pkgfile"
PKGMK_PKGFILE=""
PKGMK_FOOTPRINT=".footprint"
PKGMK_MD5SUM=".md5sum"
PKGMK_SHA256SUM=".sha256sum"
PKGMK_NOSTRIP=".nostrip"

PKGMK_SOURCE_MIRRORS=()
PKGMK_SOURCE_DIR="$PWD"
PKGMK_PACKAGE_DIR="$PWD"
PKGMK_WORK_DIR="$PWD/work"

PKGMK_COMPRESSION_MODE="gz"

PKGMK_INSTALL="no"
PKGMK_RECURSIVE="no"
PKGMK_DOWNLOAD="no"
PKGMK_DOWNLOAD_ONLY="no"
PKGMK_EXTRACT_ONLY="no"
PKGMK_UP_TO_DATE="no"
PKGMK_UPDATE_FOOTPRINT="no"
#if defined debian
PKGMK_IGNORE_FOOTPRINT="yes"
#else
PKGMK_IGNORE_FOOTPRINT="no"
#endif
PKGMK_IGNORE_NEW="no"
PKGMK_FORCE="no"
PKGMK_KEEP_WORK="no"
PKGMK_UPDATE_MD5SUM="no"
#if defined debian
PKGMK_IGNORE_MD5SUM="yes"
#else
PKGMK_IGNORE_MD5SUM="no"
#endif
PKGMK_CHECK_MD5SUM="no"
PKGMK_UPDATE_SHA256SUM="no"
#if defined debian
PKGMK_IGNORE_SHA256SUM="yes"
#else
PKGMK_IGNORE_SHA256SUM="no"
#endif
PKGMK_CHECK_SHA256SUM="no"
PKGMK_NO_STRIP="no"
PKGMK_CLEAN="no"
PKGMK_CHECK="no"
PKGMK_CHECK_PKGFILE="no"

PKGMK_ARCH="@ARCH@"
PKGMK_KERNEL="@KERNEL@"

readonly PKGMK_DOWNLOAD_TOOLS=(curl wget)
#if defined curl
DOWNLOAD_TOOL="curl"
#else // wget is the default download tool used.
DOWNLOAD_TOOL="wget"
#endif

main "$@"

